作用域和闭包
===
### 作用域理解小结

-----
1. 作用域是一套规则，用于确定在何处一级如何查找变量（标识符）；
2. 如果查找的目的是对变量进行赋值，则执行LHS查询；
3. 如果目的是获取变量的值，就会使用RHS查询；
4. JS引擎首先会在代码执行前对其进行编译
	- 首先，var a在其作用域声明新变量
	- 接下来，a=2会LHS查询变量a并对其进行赋值
5. LHS和RHS查询都会从当前作用域开始，如果有需要就会像上级作用域查询，直到全局作用域，然后停止；
6. 不成功的引用
	- RHS引用失败会抛出ReferenceError异常；
	- 非严格模式下，不成功的LHS引用会自动隐式创建一个全局变量，该变量使用LHS引用的目标作为标识符
	- 严格模式下，抛出ReferenceError错误

### 词法作用域小结

---
1. 词法作用域意味着作用域是由书写代码时函数声明的位置来决定的
2. JS中有两个机制可以欺骗词法作用域：
3. eval():可以对一段包含一个或多个声明的“代码”字符串进行演算，借此来修改已经存在的词法作用域；
4. with：通过讲一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建一个新的词法作用域
5. 词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。它的定义过程发生在代码的书写阶段。

### 函数作用域和块作用域小结

-----
1. 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用和复用，在嵌套的作用域内也可以使用。
2. 块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块。
3. try/catch的catch分句会创建一个块作用域，其声明的变量仅仅在catch内部有效。
4. let关键字可以将变量绑定到所在的任意作用域中。
5. 为变量显式声明块作用域，并对变量进行本地绑定。
6. const声明一个不可变的变量到快作用域。

### 提升小结

-----
1. 先有声明，后有赋值！
2. **变量和函数**声明会从他们在代码中出现的位置被移动到最上面，这个过程叫做提升。
3. var a=2；var a 被移动到最上面，a=2在原地。第一个是编译阶段的任务，第二个是执行阶段的任务；
4. 函数声明会被提升，但是函数表达式不会；

	<pre><code>foo();
	function foo(){
	  console.log(a); //undefined
	  var a=3;
	}
	</code></pre>
	<pre><code>foo();
	var foo=function bar(){
	  console.log(a); //TypeError，不是ReferenceError
	  var a=3;
	}
	</code></pre>
5. 函数首先被提升，然后才是变量；

### 作用域闭包小结

---
1. 当函数可以记住并访问所在的词法作用域时，就产生了闭包；在下述代码段中，函数bar()具有一个涵盖foo()作用域的闭包；

	<pre><code>function foo(){
	  var a=2;
	  function bar(){
	    console.log(a);
	  }
	  bar();
	}
	foo();
	</code></pre>
2. 闭包效果，这个例子中，将bar所引用的函数对象本身当作返回值。

    在foo()被执行后，其返回值赋值给baz并调用baz()，实质是通过不同的标识符引用了内部的函数bar()：

	<pre><code>function foo(){
      var a=2;
	  function bar(){
	    console.log(a);
	  }
	  return bar;
    }
	var baz=foo();
	baz();//2
	</code></pre>
3. 间接传递函数

    <pre><code>var fn;
	function foo(){
	  var a=2;
	  function baz(){
	    console.log(a);
	  }
	  fn=baz;//将baz分配给全局变量
	}
	function bar(){
	  fn();
	}
	foo();
	bar();//2
	</code></pre>
4. 以上例子，无论通过何种手段将内部函数传递到所在词法作用域外，他都持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
5. 本质上：如果将函数当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用；只要使用了回掉函数，实际上就是使用闭包。
6. 模块模式需要两个必要条件
	- 必须有外部的封闭函数，该函数至少被调用一次；
	- 封闭函数必须至少返回一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问和修改私有的状态。
7. 现在的模块机制：为函数定义引入包装函数，并保证他的返回值和模块的API保持一致。

	<pre><code>var MyModules=(function Manager(){
	  var modules={};
	  function define(name, deps, impl){
		for (var i=0;i < deps.length;i++) {
		  deps[i]=modules[deps[i]];
		}
			modules[name]=impl.apply(impl, deps);
		}
		function get(name){
			return modules[name];
		}
		return {
			define: define,
			get: get
		};
	})();
	MyModules.define("bar", [], function(){
		function hello(who){
			return "let me introduce: "+who;
		}
		return {
			hello: hello
		};
	});
	MyModules.define("foo", ["bar"], function(bar){
		var hungry="hippo";
		function awesome(){
			console.log(bar.hello(hungry).toUpperCase())
		}
		return {
			awesome: awesome
		};
	});
	var bar=MyModules.get("bar");
	var foo=MyModules.get("foo");
	console.log(bar.hello("hippo"));
	foo.awesome();
	</code></pre>

### 附录

---
1. 动态作用域和词法作用域，以下例子中foo()中的a通过RHS引用到全局作用域中的2，因此输出2。如果是动态作用域，作用域链会基于调用栈，而不是代码中的作用域嵌套。

    <pre><code>function foo(){
	  console.log(a);//2
	};
	function bar(){
	  var a=3;
	  foo();
	}
	var a=2;
	bar();
	</code></pre>
2. ES6的块级作用域在ES6之前可以用catch语句来代替

	<pre></code>{
	  let a=6;
	  console(a);//2
	}
	console.log(a);//referenceError
	</code></pre>

	<pre></code>try{throw 2;}catch(a){
	  console.log(a);//2
	}
	console.log(a);//referenceError
	</code></pre>
